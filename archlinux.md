# ArchLinux for Lichee Pi Nano

## Linux Kernel

О нём много писано, много сказано, а сейчас пригодится лишь несколько фактов:

    Встреченные мною дистрибутивы хранят ядро в нескольких формах:
    *    Image — не сжатый образ.
    *    zImage — сжатый самораспаковываяющийся образ.
    *    uImage — образ, который имеет обёртку, включающую некоторую информацию для U-Boot'а.

Ранее uImage использовались обширно для устройств с U-Boot, но за последние года разработчики научили загрузчик работать с zImage, который стал общепринятой практикой хранения образа ядра в дистрибутиве Arch Linux ARM.
Радостная новость! Ядро в пределах одной архитектуры(ARMv5, ARMv6, ARMv7, ARMv8) с большой вероятностью не придётся компилировать для каждого устройства. Оно использует свою версию Device Tree, называемую Device Tree Binary (dtb). Это небольшие по объёму файлы, указывающие ядру какие модули нужно подгружать. Больше информации о dtb можно узнать тут.


## От теории к практике

Понадобится:

   * Banana Pi или другой микрокомпьютер из списка поддерживаемых U-Boot'ом устройств
   * Карта памяти и кардридер
   * Компьютер с Linux
   * Установленный тулчейн для нужной архитектуры
        
        ```Где взять?
        Наиболее простым способом я считаю следующий:
        
        Скачать готовый тулчейн для своей платформы с сайта Linaro.
        Для Banana Pi нужен linaro-toolchain-binaries (little-endian).
        Добавить папку bin тулчейна в PATH:

        export PATH=~/your_toolchain_path/bin/:$PATH
        ```
    * Утилиты bc и dtc нужные для компиляции загрузчика, пакеты dosfstools и uboot-tools для создания файловой системы и компиляции скриптов загрузчика, соответственно


Скачаем и распакуем исходные коды последней версии U-Boot:

```bash wget ftp://ftp.denx.de/pub/u-boot/u-boot-latest.tar.bz2
tar -jxf u-boot-latest.tar.bz2
```

Находим в появившемся каталоге `u-boot-2015.07/configs` свою «железку» и запоминаем название файла. Для Banana Pi конфигурационный файл называется `Bananapi_defconfig`.

Ещё помните, что ядро Arch Linux ARM дистрибутиве хранится в zImage? Об этом нужно позаботиться заранее и перед компиляцией добавить возможность загружать самораспаковывающиеся ядра. Точной информации о том уже включено ли это по умолчанию у меня нет, поэтому в каталоге `u-boot-2015.07/include/configs/` нужно найти заголовочный файл для платформы Вашего микрокомпьютера (для Banana Pi это `sun7i.h`) и написать внутри:

```cpp
#ifndef __CONFIG_H
#define __CONFIG_H
...
#endif /* __CONFIG_H */
```

строку
```cpp
#define CONFIG_CMD_BOOTZ
```

Это добавит возможность использовать в загрузчике команду bootz для запуска самораспаковывающихся сжатых программ.Источник

Теперь этап компиляции. Все операции происходят в каталоге u-boot-2015.07.
А что если без кросс-компиляции?

```bash
make CROSS_COMPILE=arm-linux-gnueabihf- Bananapi_defconfig
```

Непосредственно компиляция загрузчика:

```bash
make CROSS_COMPILE=arm-linux-gnueabihf-
```

В итоге в нашей рабочей папке должно появиться много файлов с префиксом u-boot. u-boot.bin содержит исполняемый файл загрузчика, но нужен нам файл с постфиксом «with-spl». SPL — небольшая программа, которая располагается непосредственно перед загрузчиком и загружает сам U-Boot в оперативную память. Для Banana Pi это файл `u-boot-sunxi-with-spl.bin`. Сохраним его, он пригодится чуть позже.

Следующий шаг — подготовка флеш-карты с которой будет загружаться система. Как должна выглядеть её разметка:



Подключим флеш-карту через кард-ридер и запустим утилиту fdisk:

```bash
fdisk /dev/sdb
```

Как узнать какое имя у Вашей карты?

Добавим MBR разметку:

```bash

Command (m for help): o
Created a new DOS disklabel with disk identifier 0xa53166ce.
```

И обязательно как минимум два раздела:

    50-100 Мб
    fdisk, разметка первого

    2 Гб и более
    fdisk, разметка второго


После всего этого ввести «w», тем самым записать изменения на диск.

Почему именно такие разделы? U-Boot'ом можно управлять с помощью скриптов, он читает их только из первого раздела накопителя, причём раздел этот должен быть с файловой системой FAT. В этот же раздел будет смонтирован каталог /boot будущего Arch Linux'а для удобного доступа к ядрам как из U-Boot скриптов, так и для быстрой подмены ядер с любого попавшегося компьютера. Второй раздел предназначен для корня системы. Остальные по желанию.

После разметки нужно очистить место для загрузчика. Крайне важно не затереть первые 512 байт(MBR) и не затронуть 1024 секторы и далее (исходя из таблицы выше):

```bash
dd if=/dev/zero of=/dev/sdb bs=1K count=1023 seek=1
```

Запишем U-Boot:

```bash
dd if=u-boot-sunxi-with-spl.bin of=/dev/sdb bs=1024 seek=8
```

Теперь уже можно вставить флешку в устройство назначения, включить его и посмотреть как оно весело мигает LED'ами, подхватывает ip-адрес через dhcp, пытается достучаться до tftp сервера чтобы загрузиться и дружелюбно приглашает Вас в свой Shell показывая его через выдеовыход или UART.

Но одного загрузчика мало, остаётся ещё несколько компонентов: скрипт для управления U-Boot'ом и сам дистрибутив Arch Linux.
Отправляемся на os.archlinuxarm.org и скачиваем архив с подходящим нашей архитектуре дистрибутивом. Для Banana это ArchLinuxARM-armv7-latest.tar.gz. Распаковываем в отдельную директорию и продолжаем манипуляции с флеш-картой.

Создадим файловые системы и примонтируем их в заданном порядке:

```bash
mkfs.vfat /dev/sdb1
mkfs.ext4 /dev/sdb2
mount /dev/sdb2 /mnt
mkdir /mnt/boot
mount /dev/sdb1 /mnt/boot
```

Скопируем всё содержимое распакованного архива в /mnt:

```bash
cp -r ~/ArchLinux-generic-armv7/* /mnt
```

Заглянем в первый раздел флешки (/mnt/boot). Внутри нас ждёт папка dtbs и сжатый образ ядра — zImage. dtbs — это именно те Device Tree Binary, о которых шла речь выше.
Для ARMv7 есть целых 301 dtb. Список можно увидеть здесь или непосредственно открыв директорию boot/dtbs дистрибутива на своём компьютере. Если dtb есть, то ядро заведётся с почти 100% вероятностью. Для Banana Pi нужный файл — sun7i-a20-bananapi.dtb. Он нужен нам для последнего и завершающего этапа — написания скрипта для U-Boot'а и, естественно, запуска всей полученной системы.

Приступим. Создадим прямо на месте (в /mnt/boot) файл boot.cmd и начнём писать.

Первым делом прикажем U-Boot'у загружать в RAM образ ядра:

```
fatload mmc 0 0x46000000 zImage
```

Затем dtb для нужного девайса:

```
fatload mmc 0 0x49000000 dtbs/sun7i-a20-bananapi.dtb
```

Установим параметры для запуска ядра:

```
setenv bootargs console=ttyS0,115200 earlyprintk root=/dev/mmcblk0p2 rw rootwait panic=10
```

И скажем ему загружаться из этой области памяти, тем самым передавая управление уже ядру Linux.

```
bootz 0x46000000 - 0x49000000
```

Области памяти доступные для загрузки у каждой модели свои и к сожалению я не знаю как определять их самостоятельно. Буду очень рад, если кто-то расскажет об этом простыми словами в комментариях.

Написанный нами скрипт остаётся только скомпилировать. Для этого в пакете uboot-tools есть утилита mkimage, воспользуемся ей:

```
mkimage -C none -A arm -T script -d boot.cmd boot.scr
```

boot.cmd при желании можно удалить, загрузчику нужен лишь boot.scr.
А бывает ещё что-то вроде boot.scr?

И последний штрих — добавляем в etc/fstab новой системы разделы, которые будут подключаться при запуске:

```
/dev/mmcblk0p2    /    ext4    rw,relatime,data=ordered 0 1
/dev/mmcblk0p1 /boot vfat rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro 0 2
```

Флешку можно вставлять в девайс и радоваться свежей системе. Демон dhcpd сам подхватит адрес если в Вашей сети есть DHCP сервер. SSH сервер по умолчанию добавлен в автозагрузку. Аккаунт на дефолтных образах Arch Linux ARM изначально всегда один: root/root. Обязательно смените пароль и добавьте юзера с ограниченными полномочиями.